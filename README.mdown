
`_package.js` is a package manager very very similar to [require.js].
I quite like *most* of the design decisions in it, but the only thing
I don't agree is that modules are referred to using paths, which makes
module use dependent on file system location.

`_package.js` on the other hand requires you to provide a package
name that is likely globally unique .. and is closer to the "goog.provide"
approach. Package names are therefore of the form `"from.top.to.bottom"`.
This is also compatible with the Java-like reverse-DNS package naming 
conventions.

Just like [require.js], `_package` also lends itself to easy minification
using, say, the closure compiler.

## Usage ##

### _package(name) ###

Returns the currently loaded package of the given name. If `"com.anthill.worker"`
is a valid package name, then there are related package names that you can
access as well, such as `"com.anthill.*"` and `"com.*"`. Therefore all of
the following are equivalent -

    _package("*").com.anthill.worker
    _package("com.*").anthill.worker
    _package("com.anthill.*").worker
    _package("com.anthill.worker")

### _package(name, definition) ###

`definition` is either a normal value or a function. If the latter, it
is called and the return value of the function is used as the package value.

    _package('com.anthill.worker', function () {
        // prepare worker resources.
        return worker;
    });

Within the package definition function, `this` refers to the current package
object being defined, so you can also add exports by assigning properties
to `this`. If you don't have a `return` statement within the definition
function, or do a `return;` or a `return undefined;` then the value that
`this` held is kept as the package value. Otherwise the package object is
defined by the return value of the definition function. Doing it this way
lets you augment an already defined package by writing a definition function
that modifies `this`.

> In contrast to [require.js], `_package.js` doesn't mind you organizing your
> packages in whatever way you want. The mapping between the package names and
> file names is only provided as a convenience and the recommended way to use
> `_package` is to setup any file related mappings externally.  Stuff needed to
> *build* a system shouldn't be mixed up with definitions of the system's
> components.

### _package(name, dependencies, definition) ###

`dependencies` is an array of package names that must be loaded before this
package's definition function can be called. Generally speaking, you need to
specify full package names for the dependencies, but if the dependency shares
the same parent package as the package being defined, it can be specified as a
"sibling" by starting its name with a "." and omitting the common prefix.  For
example, the following two are equivalent -

    _package('com.anthill.fighter', ['com.anthill.worker'], function (Worker) {
        // .. do something ..
        return worker;
    });

    _package('com.anthill.fighter', ['.worker'], function (Worker) {
        // .. do something ..
        return worker;
    });

One other handy feature when you use such relative package names is
that if the dependency has no configuration information that tells the system
where to load the package from, it will inherit this configuration from
that of the package being defined. This means that if the `fighter`
package above is being loaded from `theredone/foo-fighter.js`, then
the `worker` will be loaded from `theredone/worker.js`. This lets you have
a "main.js" package that lists every other sibling package as a dependency
and does pretty much nothing else. Listing this main package as a dependency
for another package will result in the whole package being loaded.

The `this` support for extending packages described in the previous section 
also applies to this three-argument form.

#### Experimental "__listing__" feature ####

If a dependency name ends with an asterisk, like `"another.package.*"`, then
the special package named `"another.package.__listing__"` is checked.  That
"package" is expected to be an array of other sub-package names, all of which
will be included as dependencies of the package that refers to
"another.package.*" and the corresponding argument will be an object whose keys
are the sub-package names and whose values are the sub-packages' contents.

### Configuring load locations ###

A package's path is normally derived from its name if left unspecified
by substituting '/' for '.' just like the Java packaging scheme. So 
`"com.anthill.worker"` will be fetched from `"com/anthill/worker.js"`.
You can override this using `_package.config` as follows -

    _package.config({
        'com.anthill.worker': {path: 'worker2.js', alias: 'w2'},
        //...
    });

Notice that above we've also given an (optional) alias to that package
and we can from this point on refer to the package just using `'w2'`.

You can also directly fetch a package from a URL by specifying `url:` 
instead of `path:`. This works in node.js as well as in the browser.

### Forward delarations ###

When concatenating files for minification, you do not want the package
manager to automatically try to load dependencies. For such cases, you
can use `_package.declare` to indicate that these packages will be
loaded without the help of the package manager.

    _package.declare([
        'com.anthill.worker',
        'com.anthill.fighter',
        //...
    ]);

You place such a declare statement at the start of your collection of packages
and simply concat all the package definition files.  

I want to liberate source code from files and separating the mapping from
package to source from the definition of a package and its dependencies
is my little contribution to that.

[require.js]: http://requirejs.org/
